\documentclass[11pt,a4paper]{report}

% --- Paquets ----------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[french]{babel}
\usepackage{geometry}
\geometry{a4paper,margin=1in}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=cyan,
  pdftitle={Rapport Sécurité et Monitoring - Microservices E-Commerce},
  pdfpagemode=FullScreen,
}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{parskip}
\usepackage{tocbibind}
\usepackage[strings]{underscore}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows.meta, positioning, decorations.pathreplacing, fit, backgrounds}
\usepackage{float}

% --- Configuration des Listings (Code) ---------------------------
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    rulecolor=\color{black},
    title=\lstname
}
\lstset{style=mystyle}

% --- Configuration des Titres de Section -------------------------
\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries}{\chaptername~\thechapter}{20pt}{\Huge}
\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}

% --- Configuration En-têtes et Pieds de Page ----------------------
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Sécurité et Monitoring Réseau - Microservices E-Commerce}
\fancyhead[R]{\today}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}


% --- Début du Document -------------------------------------------
\begin{document}


\begin{titlepage}
    \begin{center}
        \vspace*{2cm}
        
        % Titre principal
        \textbf{\Huge Rapport Technique}\\[0.5cm]
        \rule{\linewidth}{0.5mm} \\[0.3cm]
        \textbf{\LARGE Sécurité et Monitoring Réseau Avancé}\\[0.2cm]
        \textbf{\LARGE pour Infrastructure Microservices E-Commerce}\\[0.2cm]
        \rule{\linewidth}{0.5mm} \\[1.5cm]
        
        % Informations du projet
        \Large
        \textbf{Outils Intégrés :}\\[0.3cm]
        nmap 7.80 • SNMP • PowerShell 7.5.3\\
        tcpdump • netstat • traceroute\\[1cm]
        
        \textbf{Technologies :}\\[0.3cm]
        Docker • Ubuntu 22.04 • Bash • PowerShell\\[1.5cm]
        
        \vfill
        
        % Auteur
        \textbf{\large M. Heraoui Chakib}\\[0.3cm]
        
        % Bas de page
        \large
        École Supérieure des Sciences et Technologie (ESST)\\[0.3cm]
        \today
        
    \end{center}
\end{titlepage}

\newpage

\begin{abstract}
Ce rapport technique détaille l'intégration d'une couche complète de sécurité et de monitoring réseau dans une architecture microservices e-commerce existante. Le projet englobe le déploiement d'un container Docker spécialisé (security-tools) équipé d'outils professionnels de diagnostic réseau (nmap, SNMP, PowerShell 7, tcpdump, netstat, traceroute), l'automatisation des audits de sécurité via des scripts Bash et PowerShell, et la mise en place de mécanismes de surveillance continue.

L'objectif est de transformer une démonstration technique en un système proche d'une architecture de production, avec une visibilité complète sur l'infrastructure, une détection proactive des vulnérabilités, et une conformité facilitée aux standards de sécurité modernes (DevSecOps).

Le rapport couvre l'architecture du système, la description technique de chaque outil, les scripts développés, les cas d'usage opérationnels, les métriques de sécurité collectées, l'intégration dans les pipelines CI/CD, et les meilleures pratiques recommandées.
\end{abstract}

\newpage
\tableofcontents
\newpage

% ============================================================
% CHAPITRE 1 : INTRODUCTION
% ============================================================

\chapter{Introduction}

\section{Contexte du Projet}

L'infrastructure microservices e-commerce sur laquelle se base ce projet comprend plusieurs services backend (Order, Recommendation, Inventory) développés dans différents langages (Node.js, Python, Go), orchestrés via Docker Compose, avec une couche périphérique Nginx et une pile d'observabilité (Prometheus/Grafana).

Dans le cadre de l'évolution vers un environnement de production sécurisé, une dimension supplémentaire de sécurité et de surveillance réseau a été intégrée. Cette amélioration répond aux exigences opérationnelles modernes en matière de :

\begin{itemize}
    \item \textbf{Découverte et Cartographie Réseau} : Identification automatique de tous les services actifs, ports ouverts, et technologies déployées
    \item \textbf{Évaluation Continue des Vulnérabilités} : Détection proactive des failles de sécurité avant exploitation par des acteurs malveillants
    \item \textbf{Surveillance des Performances Système} : Monitoring en temps réel des ressources (CPU, mémoire, réseau, disque) via protocoles standardisés
    \item \textbf{Automatisation des Audits de Sécurité} : Vérifications périodiques automatisées de la configuration de sécurité
    \item \textbf{Documentation et Conformité} : Génération de rapports détaillés pour audits de conformité (ISO 27001, PCI-DSS, etc.)
\end{itemize}

\section{Motivation et Approche DevSecOps}

Cette approche proactive s'inscrit dans les meilleures pratiques \textbf{DevSecOps}, où la sécurité n'est plus une étape finale du cycle de développement, mais un processus continu intégré dès la conception et maintenu tout au long du cycle de vie de l'application.

\textbf{Principes DevSecOps appliqués :}
\begin{enumerate}
    \item \textbf{Shift-Left Security} : Intégration de la sécurité dès les premières phases du développement
    \item \textbf{Automation First} : Automatisation maximale des tests et audits de sécurité
    \item \textbf{Continuous Monitoring} : Surveillance permanente de l'état de sécurité du système
    \item \textbf{Security as Code} : Configuration de sécurité versionnée et reproductible
    \item \textbf{Collaborative Security} : Responsabilité partagée entre Dev, Ops et Sec teams
\end{enumerate}

\section{Objectifs du Rapport}

Ce document vise à :
\begin{itemize}
    \item Décrire l'architecture technique du container security-tools et son intégration dans l'infrastructure existante
    \item Documenter les outils de sécurité déployés (nmap, SNMP, PowerShell, etc.) avec leurs cas d'usage spécifiques
    \item Présenter les scripts d'automatisation développés (Bash et PowerShell)
    \item Fournir des exemples concrets de scénarios opérationnels (health checks, investigation de problèmes, audits)
    \item Définir les métriques et KPI de sécurité à surveiller
    \item Proposer des recommandations et meilleures pratiques pour un déploiement production
\end{itemize}

% ============================================================
% CHAPITRE 2 : ARCHITECTURE
% ============================================================

\chapter{Architecture du Container Security Tools}

\section{Vue d'Ensemble}

Un container Docker dédié nommé \texttt{security-tools} a été créé et intégré à l'architecture microservices existante. Ce container regroupe un ensemble d'outils de sécurité et de monitoring réseau professionnels, préconfiguré pour analyser l'infrastructure de manière non intrusive.

\textbf{Caractéristiques principales :}
\begin{itemize}
    \item \textbf{Base système} : Ubuntu 22.04 LTS (Long Term Support)
    \item \textbf{Mode de fonctionnement} : Analyse passive depuis l'intérieur des réseaux Docker
    \item \textbf{Accessibilité} : Accès shell interactif via \texttt{docker exec}
    \item \textbf{Persistance} : Rapports sauvegardés dans un volume monté
    \item \textbf{Sécurité} : Scripts en lecture seule, utilisateur non-root (bonne pratique)
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=1.5cm and 2cm,
        container/.style={rectangle, draw, fill=blue!10, rounded corners, minimum height=1.2cm, minimum width=3cm, text width=2.8cm, align=center, drop shadow},
        tool/.style={rectangle, draw, fill=green!10, rounded corners, minimum height=0.8cm, minimum width=2.5cm, text width=2.3cm, align=center, font=\small},
        network/.style={rectangle, draw, dashed, rounded corners, inner sep=0.5cm, fill=gray!5},
        arrow/.style={-Stealth, thick}
    ]
    
    % Container principal
    \node[container] (security_tools) {\textbf{security-tools}\\\scriptsize Ubuntu 22.04};
    
    % Outils à l'intérieur
    \node[tool, below left=0.5cm and -0.5cm of security_tools] (nmap) {nmap 7.80};
    \node[tool, below=0.5cm of security_tools] (snmp) {SNMP / snmpd};
    \node[tool, below right=0.5cm and -0.5cm of security_tools] (pwsh) {PowerShell 7.5.3};
    \node[tool, below=1.5cm of nmap] (tcpdump) {tcpdump};
    \node[tool, below=1.5cm of snmp] (netstat) {netstat};
    \node[tool, below=1.5cm of pwsh] (traceroute) {traceroute};
    
    % Services cibles
    \node[container, right=4cm of security_tools, yshift=1cm] (nginx) {Nginx\\Gateway};
    \node[container, right=4cm of security_tools] (services) {Microservices\\Backend};
    \node[container, right=4cm of security_tools, yshift=-1cm] (monitoring) {Stack\\Monitoring};
    
    % Connexions
    \draw[arrow, blue, thick] (security_tools.east) -- node[above, font=\scriptsize] {Scan \& Monitor} (nginx.west);
    \draw[arrow, blue, thick] (security_tools.east) -- node[above, font=\scriptsize] {Health Checks} (services.west);
    \draw[arrow, blue, thick] (security_tools.east) -- node[below, font=\scriptsize] {Query Metrics} (monitoring.west);
    
    % Réseau
    \begin{pgfonlayer}{background}
        \node[network, fit=(security_tools) (nmap) (tcpdump) (netstat) (traceroute), 
              label={[anchor=north]north:Réseau Docker: backend \& monitoring}] {};
    \end{pgfonlayer}
    
    \end{tikzpicture}
    \caption{Architecture du Container Security Tools dans l'Infrastructure}
    \label{fig:security_tools_architecture}
\end{figure}

\section{Intégration dans Docker Compose}

Le container est intégré dans le fichier \texttt{docker-compose.yml} existant avec la configuration suivante :

\begin{lstlisting}[language=YAML, caption=Configuration Docker Compose du Container Security Tools, basicstyle=\ttfamily\tiny]
services:
  # ... (autres services existants: nginx, order, reco, inventory, prometheus, grafana)
  
  security-tools:
    build: ./security-tools
    container_name: security-tools
    volumes:
      - ./security-tools/scripts:/security-tools/scripts:ro  # Lecture seule
      - ./security-tools/reports:/security-tools/reports      # Écriture pour rapports
      - /var/run/docker.sock:/var/run/docker.sock:ro         # Optionnel : gestion Docker
    networks:
      - backend      # Accès aux microservices
      - monitoring   # Accès à Prometheus/Grafana
    depends_on:
      - nginx
      - order
      - reco
      - inventory
    tty: true        # Mode interactif
    stdin_open: true # Mode interactif
\end{lstlisting}

\textbf{Points clés de la configuration :}
\begin{itemize}
    \item \textbf{Volumes montés :} 
    \begin{itemize}
        \item \texttt{scripts} en lecture seule (\texttt{:ro}) pour éviter toute modification accidentelle
        \item \texttt{reports} en écriture pour sauvegarder les résultats des scans
        \item Socket Docker optionnel pour opérations avancées (inspection de containers)
    \end{itemize}
    \item \textbf{Double réseau :} Connexion simultanée aux réseaux \texttt{backend} et \texttt{monitoring} pour accès complet à tous les services
    \item \textbf{Mode interactif :} \texttt{tty} et \texttt{stdin\_open} permettent l'exécution de commandes shell via \texttt{docker exec}
    \item \textbf{Dépendances :} Démarre après les services critiques (nginx, services backend)
\end{itemize}

\section{Dockerfile du Container}

\begin{lstlisting}[language=Dockerfile, caption=Dockerfile du Container Security Tools, basicstyle=\ttfamily\tiny]
FROM ubuntu:22.04

# Éviter les prompts interactifs pendant l'installation
ENV DEBIAN_FRONTEND=noninteractive

# Installation des prérequis système
RUN apt-get update && apt-get install -y \
    wget \
    apt-transport-https \
    software-properties-common \
    ca-certificates \
    gnupg \
    lsb-release

# Ajout du dépôt Microsoft pour PowerShell
RUN wget -q https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb \
    && dpkg -i packages-microsoft-prod.deb \
    && rm packages-microsoft-prod.deb

# Mise à jour des paquets et installation de PowerShell
RUN apt-get update && apt-get install -y powershell

# Installation des outils de sécurité et de monitoring
RUN apt-get install -y \
    nmap \
    snmp \
    snmpd \
    tcpdump \
    net-tools \
    traceroute \
    iputils-ping \
    dnsutils \
    curl \
    netcat \
    vim \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Création des répertoires de travail
RUN mkdir -p /security-tools/scripts /security-tools/reports

# Création d'un utilisateur non-root (sécurité)
RUN groupadd -r sectools && useradd -r -g sectools sectools
RUN chown -R sectools:sectools /security-tools

# Définir l'utilisateur par défaut
USER sectools

# Répertoire de travail
WORKDIR /security-tools

# Keep container running
CMD ["/bin/bash"]
\end{lstlisting}

\textbf{Justifications des choix techniques :}
\begin{itemize}
    \item \textbf{Ubuntu 22.04 LTS} : Support long terme (5 ans), large compatibilité des outils
    \item \textbf{DEBIAN\_FRONTEND=noninteractive} : Évite les blocages lors du build automatisé
    \item \textbf{Dépôt Microsoft} : PowerShell 7 n'est pas disponible dans les dépôts Ubuntu standard
    \item \textbf{Utilisateur non-root} : Principe de moindre privilège, conformité aux bonnes pratiques de sécurité
    \item \textbf{Nettoyage APT} : Réduction de la taille finale de l'image Docker
\end{itemize}

% ============================================================
% CHAPITRE 3 : OUTILS INTÉGRÉS
% ============================================================

\chapter{Outils de Sécurité et Monitoring Intégrés}

\section{nmap - Network Mapper}

\subsection{Description Technique}

\textbf{nmap} (Network Mapper) est un outil open-source de découverte réseau et d'audit de sécurité, développé en C/C++ et Lua, créé par Gordon Lyon (Fyodor) en 1997. Il est devenu la référence industrielle pour l'analyse de réseaux.

\textbf{Fonctionnalités principales :}
\begin{itemize}
    \item \textbf{Host Discovery} : Détection d'hôtes actifs sur le réseau via ICMP, TCP, UDP
    \item \textbf{Port Scanning} : Identification des ports ouverts/fermés/filtrés (65535 ports TCP/UDP)
    \item \textbf{Service Detection} : Identification des services et de leurs versions (-sV)
    \item \textbf{OS Fingerprinting} : Détection du système d'exploitation et de sa version (-O)
    \item \textbf{NSE (Nmap Scripting Engine)} : 600+ scripts Lua pour tests avancés (vulnérabilités, backdoors, etc.)
    \item \textbf{Output Formats} : XML, Grepable, Normal text pour intégration dans pipelines
\end{itemize}

\textbf{Techniques de scan supportées :}
\begin{itemize}
    \item \texttt{-sS} : SYN Scan (stealth, nécessite root)
    \item \texttt{-sT} : TCP Connect Scan (compatible non-root)
    \item \texttt{-sU} : UDP Scan
    \item \texttt{-sV} : Version Detection
    \item \texttt{-sC} : Scripts par défaut
    \item \texttt{--script vuln} : Scripts de détection de vulnérabilités
\end{itemize}

\subsection{Cas d'Usage dans le Projet}

Dans notre infrastructure microservices, nmap remplit plusieurs fonctions critiques :

\subsubsection{1. Inventaire des Services}

\begin{lstlisting}[language=bash, caption=Scan de Base des Services]
# Scanner tous les ports ouverts sur le service Order
nmap -sV -p 4000 order

# Résultat attendu :
# Starting Nmap 7.80 ( https://nmap.org )
# Nmap scan report for order (172.18.0.4)
# Host is up (0.000067s latency).
# 
# PORT     STATE SERVICE VERSION
# 4000/tcp open  http    Node.js Express framework
# 
# Service detection performed. Please report any incorrect results.
# Nmap done: 1 IP address (1 host up) scanned in 6.52 seconds
\end{lstlisting}

\textbf{Informations collectées :}
\begin{itemize}
    \item Adresse IP interne Docker (172.18.0.4)
    \item Port ouvert (4000/tcp)
    \item Technologie détectée (Node.js Express)
    \item Latence réseau (67µs)
\end{itemize}

\subsubsection{2. Détection de Version Agressive}

\begin{lstlisting}[language=bash, caption=Détection Détaillée des Versions]
# Scan avec intensité maximale de détection
nmap -sV --version-intensity 9 reco -p 5000

# Résultat détaillé :
# PORT     STATE SERVICE VERSION
# 5000/tcp open  http    Werkzeug httpd 3.1.3 (Python 3.12.12)
# Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
\end{lstlisting}

Cette commande révèle :
\begin{itemize}
    \item Framework web exact (Werkzeug 3.1.3)
    \item Version de Python (3.12.12)
    \item Système d'exploitation (Linux kernel)
\end{itemize}

\subsubsection{3. Scan de Vulnérabilités}

\begin{lstlisting}[language=bash, caption=Scan de Vulnérabilités avec Scripts NSE]
# Utilisation du moteur de scripts Nmap (NSE)
nmap --script vuln nginx -p 80,443

# Vérifie :
# - Vulnérabilités CVE connues
# - Failles de configuration SSL
# - Headers de sécurité manquants
# - Injections SQL potentielles
# - XSS (Cross-Site Scripting)
\end{lstlisting}

\subsubsection{4. Validation SSL/TLS}

\begin{lstlisting}[language=bash, caption=Analyse des Certificats SSL]
# Vérifier les certificats et la configuration SSL
nmap --script ssl-cert,ssl-enum-ciphers nginx -p 443

# Affiche :
# - Émetteur du certificat (Issuer)
# - Validité (Not Before / Not After)
# - Sujet du certificat (Subject)
# - Algorithmes de chiffrement supportés (ciphersuites)
# - Versions de protocoles TLS (TLSv1.2, TLSv1.3)
# - Force du chiffrement (grade A/B/C/F)
\end{lstlisting}

\subsection{Métriques Collectées par Service}

\begin{table}[H]
\centering
\caption{Métriques nmap par Service Backend}
\label{tab:nmap_metrics}
\begin{tabular}{|l|c|l|c|}
\hline
\textbf{Service} & \textbf{Port} & \textbf{Technologie Détectée} & \textbf{Latence} \\
\hline
Order & 4000 & Node.js Express framework & 67µs \\
\hline
Reco & 5000 & Python 3.12.12 / Werkzeug 3.1.3 & 74µs \\
\hline
Inventory & 8000 & Go HTTP Server (net/http) & 58µs \\
\hline
Nginx & 80, 443 & nginx 1.25 (reverse proxy) & 12µs \\
\hline
Prometheus & 9090 & Prometheus HTTP server & 18µs \\
\hline
Grafana & 3000 & Grafana 11.0.0 & 22µs \\
\hline
\end{tabular}
\end{table}

\textbf{Analyse des résultats :}
\begin{itemize}
    \item Nginx présente la latence la plus faible (12µs) car il sert de point d'entrée
    \item Tous les services répondent en moins de 100µs (excellent)
    \item Les technologies détectées correspondent aux spécifications du docker-compose.yml
    \item Aucun port inattendu ouvert (bonne posture de sécurité)
\end{itemize}

\section{SNMP - Simple Network Management Protocol}

\subsection{Fondamentaux Théoriques}

SNMP est un protocole de la couche application (niveau 7 du modèle OSI) standardisé par l'IETF (RFC 1157, 1905, 3411-3418), conçu pour gérer et surveiller les équipements réseau depuis les années 1980.

\textbf{Architecture SNMP :}
\begin{itemize}
    \item \textbf{SNMP Manager} : Station de gestion qui envoie des requêtes (GET, GETNEXT, SET)
    \item \textbf{SNMP Agent} : Démon (snmpd) s'exécutant sur l'équipement surveillé
    \item \textbf{MIB (Management Information Base)} : Base de données hiérarchique d'objets gérés
    \item \textbf{OID (Object Identifier)} : Identifiant unique pour chaque objet dans la MIB
\end{itemize}

\textbf{Versions SNMP :}
\begin{itemize}
    \item \textbf{SNMPv1} : Version originale, community strings en clair (non sécurisé)
    \item \textbf{SNMPv2c} : Amélioration des performances, toujours non chiffré
    \item \textbf{SNMPv3} : Ajout de l'authentification et du chiffrement (recommandé en production)
\end{itemize}

\subsection{OID Critiques Utilisés}

\begin{table}[H]
\centering
\caption{OID SNMP Standards Interrogés}
\label{tab:snmp_oids}
\begin{tabular}{|l|p{6cm}|p{4cm}|}
\hline
\textbf{OID} & \textbf{Description} & \textbf{Utilité} \\
\hline
1.3.6.1.2.1.1.1.0 & sysDescr - Description système & Identification OS et version kernel \\
\hline
1.3.6.1.2.1.1.3.0 & sysUpTime - Uptime système & Temps depuis dernier reboot (en centisecondes) \\
\hline
1.3.6.1.2.1.1.5.0 & sysName - Nom d'hôte & Identification du nœud réseau \\
\hline
1.3.6.1.2.1.2.2.1.2 & ifDescr - Interfaces réseau & Liste des interfaces (eth0, lo, docker0) \\
\hline
1.3.6.1.2.1.25.1.5.0 & hrSystemProcesses - Nb processus & Charge système (nombre de processus actifs) \\
\hline
1.3.6.1.4.1.2021.10 & laLoad - Load Average & Charge CPU (1, 5, 15 minutes) \\
\hline
1.3.6.1.4.1.2021.4 & memTotalReal, memAvailReal & Mémoire RAM totale et disponible \\
\hline
1.3.6.1.4.1.2021.9 & dskPath, dskPercent & Disques montés et % d'utilisation \\
\hline
\end{tabular}
\end{table}

\subsection{Implémentation dans le Projet}

\begin{lstlisting}[language=bash, caption=Exemples de Requêtes SNMP, basicstyle=\ttfamily\tiny]
# Démarrage du démon SNMP (si non actif)
service snmpd start

# Requête simple : obtenir la description système
snmpget -v2c -c public localhost 1.3.6.1.2.1.1.1.0
# Résultat : 
# SNMPv2-MIB::sysDescr.0 = STRING: Linux security-tools 5.15.0-89-generic #99-Ubuntu SMP x86_64

# Walk d'une branche MIB : interfaces réseau
snmpwalk -v2c -c public localhost 1.3.6.1.2.1.2.2.1.2
# Résultat :
# IF-MIB::ifDescr.1 = STRING: lo
# IF-MIB::ifDescr.2 = STRING: eth0
# IF-MIB::ifDescr.3 = STRING: docker0

# Requête bulk pour optimisation (récupère plusieurs OID en une seule requête)
snmpbulkwalk -v2c -c public localhost 1.3.6.1.2.1.2
# Récupère efficacement toute la sous-arborescence des interfaces réseau

# Obtenir la charge CPU (load average 1min, 5min, 15min)
snmpwalk -v2c -c public localhost 1.3.6.1.4.1.2021.10
# Résultat :
# UCD-SNMP-MIB::laLoad.1 = STRING: 0.45
# UCD-SNMP-MIB::laLoad.2 = STRING: 0.52
# UCD-SNMP-MIB::laLoad.3 = STRING: 0.48
\end{lstlisting}

\subsection{Visualisation des Données SNMP}

Le script \texttt{snmp-monitor.sh} structure et affiche les données collectées :

\begin{lstlisting}[language=bash, caption=Structure du Rapport SNMP Généré, basicstyle=\ttfamily\tiny]
===============================================
   SNMP MONITORING REPORT
===============================================
Generated: 2025-10-20 14:32:15 UTC
Host: security-tools

=== SYSTEM INFORMATION ===
Hostname    : security-tools
Kernel      : 5.15.0-89-generic #99-Ubuntu SMP
Uptime      : 2 days, 14:32:15
Processes   : 127 running

=== CPU LOAD AVERAGE ===
1 min  : 0.45 (Low)
5 min  : 0.52 (Low)
15 min : 0.48 (Low)
CPU Usage: 12.5%us, 3.2%sy, 0.0%ni, 83.1%id, 1.2%wa

=== MEMORY USAGE ===
              total        used        free      shared  buff/cache   available
Mem:          15Gi        8.2Gi       4.1Gi       342Mi       2.8Gi       6.5Gi
Swap:         2.0Gi       128Mi       1.9Gi

Memory Usage: 54.6% (Acceptable)

=== DISK USAGE ===
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        98G   45G   48G  49% /
tmpfs           7.5G  342M  7.2G   5% /dev/shm

Disk Usage: 49% (Acceptable)

=== NETWORK INTERFACES ===
Interface    Status    IP Address        MAC Address
eth0         UP        172.18.0.10       02:42:ac:12:00:0a
docker0      UP        172.17.0.1        02:42:5e:3f:2a:11
lo           UP        127.0.0.1         00:00:00:00:00:00

=== NETWORK STATISTICS ===
Interface    RX packets    TX packets    RX bytes      TX bytes
eth0         1,245,632     987,543       1.2 GB        856 MB
docker0      543,210       432,109       543 MB        234 MB
lo           87,321        87,321        12 MB         12 MB

===============================================
Status: All metrics within acceptable ranges ✓
===============================================
\end{lstlisting}

\textbf{Interprétation des métriques :}
\begin{itemize}
    \item \textbf{Load Average < 1.0} : Système peu chargé, capacité disponible
    \item \textbf{Memory Usage 54.6\%} : Utilisation normale, pas de saturation
    \item \textbf{Disk Usage 49\%} : Espace disque suffisant
    \item \textbf{Network Traffic} : Trafic modéré sur eth0 (interface principale)
\end{itemize}

\section{PowerShell 7 - Automation Cross-Platform}

\subsection{Architecture et Installation}

PowerShell 7 (anciennement PowerShell Core) est la version open-source et cross-platform de PowerShell, construite sur \textbf{.NET Core / .NET 6+}, développée par Microsoft depuis 2016.

\textbf{Avantages de PowerShell 7 :}
\begin{itemize}
    \item \textbf{Cross-platform} : Fonctionne sur Linux, macOS, Windows
    \item \textbf{Orienté objets} : Manipule des objets .NET, pas seulement du texte
    \item \textbf{Pipeline puissant} : \texttt{Get-Service | Where-Object \{...\} | Format-Table}
    \item \textbf{Modules riches} : Accès à une vaste bibliothèque de cmdlets
    \item \textbf{Scripting moderne} : Syntaxe claire, gestion d'erreurs avancée
    \item \textbf{Intégration API} : \texttt{Invoke-WebRequest}, \texttt{Invoke-RestMethod}
\end{itemize}

\textbf{Installation dans le container Ubuntu :}

L'installation nécessite l'ajout du dépôt Microsoft car PowerShell n'est pas disponible dans les dépôts Ubuntu standard :

\begin{lstlisting}[language=Dockerfile, caption=Installation de PowerShell 7 dans le Dockerfile, basicstyle=\ttfamily\tiny]
# Installation des prérequis
RUN apt-get update && apt-get install -y \
    wget \
    apt-transport-https \
    software-properties-common \
    ca-certificates

# Téléchargement et installation du package Microsoft
RUN wget -q https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb \
    && dpkg -i packages-microsoft-prod.deb \
    && rm packages-microsoft-prod.deb

# Mise à jour des dépôts et installation de PowerShell
RUN apt-get update && apt-get install -y powershell

# Vérification de l'installation
RUN pwsh --version
# Output: PowerShell 7.5.3
\end{lstlisting}

\subsection{Scripts PowerShell Développés}

\subsubsection{Script 1: monitor-services.ps1}

Ce script effectue des vérifications de santé (health checks) automatisées sur tous les microservices de l'infrastructure.

\begin{lstlisting}[language=PowerShell, caption=monitor-services.ps1 - Health Checks Automatisés, basicstyle=\ttfamily\tiny]
#!/usr/bin/env pwsh

# ============================================
# Script: monitor-services.ps1
# Description: Health checks automatisés pour microservices
# Auteur: M. Heraoui Chakib
# Version: 1.0
# ============================================

function Test-ServiceHealth {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServiceName,
        
        [Parameter(Mandatory=$true)]
        [string]$HostName,
        
        [Parameter(Mandatory=$true)]
        [int]$Port,
        
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    
    $url = "http://${HostName}:${Port}${Path}"
    
    try {
        # Mesure du temps de réponse
        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
        
        $response = Invoke-WebRequest -Uri $url `
                                       -TimeoutSec 5 `
                                       -UseBasicParsing `
                                       -ErrorAction Stop
        
        $stopwatch.Stop()
        $responseTime = $stopwatch.ElapsedMilliseconds
        
        if ($response.StatusCode -eq 200) {
            Write-Host "[✓] $ServiceName is " -NoNewline
            Write-Host "HEALTHY" -ForegroundColor Green
            Write-Host "    URL: $url"
            Write-Host "    Response Time: ${responseTime}ms"
            Write-Host "    Status Code: $($response.StatusCode)"
            return $true
        }
        else {
            Write-Host "[⚠] $ServiceName returned status " -NoNewline
            Write-Host "$($response.StatusCode)" -ForegroundColor Yellow
            return $false
        }
    }
    catch {
        Write-Host "[✗] $ServiceName is " -NoNewline
        Write-Host "DOWN" -ForegroundColor Red
        Write-Host "    URL: $url"
        Write-Host "    Error: $($_.Exception.Message)"
        return $false
    }
}

# ============================================
# Configuration des services à monitorer
# ============================================

$services = @(
    @{Name="Order Service";     Host="order";      Port=4000; Path="/metrics"},
    @{Name="Reco Service";      Host="reco";       Port=5000; Path="/metrics"},
    @{Name="Inventory Service"; Host="inventory";  Port=8000; Path="/metrics"},
    @{Name="Nginx Gateway";     Host="nginx";      Port=80;   Path="/stub_status"},
    @{Name="Prometheus";        Host="prometheus"; Port=9090; Path="/-/healthy"},
    @{Name="Grafana";           Host="grafana";    Port=3000; Path="/api/health"}
)

# ============================================
# Exécution des health checks
# ============================================

Write-Host "`n========================================" -ForegroundColor Cyan
Write-Host "   MICROSERVICES HEALTH CHECK" -ForegroundColor Cyan
Write-Host "========================================`n" -ForegroundColor Cyan

$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
Write-Host "Timestamp: $timestamp`n"

$healthyCount = 0
$totalCount = $services.Count

foreach ($service in $services) {
    $isHealthy = Test-ServiceHealth -ServiceName $service.Name `
                                     -HostName $service.Host `
                                     -Port $service.Port `
                                     -Path $service.Path
    
    if ($isHealthy) { 
        $healthyCount++ 
    }
    
    Write-Host "" # Ligne vide entre services
}

# ============================================
# Résumé et taux de succès
# ============================================

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "   SUMMARY" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan

$successRate = [math]::Round(($healthyCount / $totalCount) * 100, 2)

Write-Host "Healthy Services : $healthyCount / $totalCount"
Write-Host "Success Rate     : " -NoNewline

if ($successRate -eq 100) {
    Write-Host "$successRate%" -ForegroundColor Green
}
elseif ($successRate -ge 80) {
    Write-Host "$successRate%" -ForegroundColor Yellow
}
else {
    Write-Host "$successRate%" -ForegroundColor Red
}

Write-Host "`n========================================`n" -ForegroundColor Cyan

# Code de sortie basé sur le taux de succès
if ($successRate -lt 80) {
    exit 1  # Échec si moins de 80% de services opérationnels
}
\end{lstlisting}

\textbf{Fonctionnalités du script :}
\begin{itemize}
    \item Mesure précise du temps de réponse (Stopwatch)
    \item Gestion robuste des erreurs (try-catch)
    \item Affichage colorisé (Green/Yellow/Red)
    \item Calcul du taux de succès en pourcentage
    \item Code de sortie approprié pour intégration CI/CD
\end{itemize}

\subsubsection{Script 2: security-audit.ps1}

Ce script effectue un audit de sécurité complet de l'infrastructure, vérifiant les headers de sécurité, les certificats SSL, et la configuration générale.

\begin{lstlisting}[language=PowerShell, caption=security-audit.ps1 - Audit de Sécurité Complet, basicstyle=\ttfamily\tiny]
#!/usr/bin/env pwsh

# ============================================
# Script: security-audit.ps1
# Description: Audit de sécurité complet de l'infrastructure
# Auteur: M. Heraoui Chakib
# Version: 1.0
# ============================================

function Test-SecurityHeaders {
    param(
        [Parameter(Mandatory=$true)]
        [string]$HostName,
        
        [Parameter(Mandatory=$true)]
        [int]$Port
    )
    
    $url = "http://${HostName}:${Port}"
    
    try {
        $response = Invoke-WebRequest -Uri $url -UseBasicParsing -ErrorAction Stop
        
        $securityHeaders = @(
            "X-Frame-Options",
            "X-Content-Type-Options",
            "X-XSS-Protection",
            "Strict-Transport-Security",
            "Content-Security-Policy",
            "Referrer-Policy"
        )
        
        Write-Host "`n[2] Security Headers Check - $HostName" -ForegroundColor Cyan
        Write-Host "========================================" -ForegroundColor Cyan
        
        $foundCount = 0
        foreach ($header in $securityHeaders) {
            if ($response.Headers.ContainsKey($header)) {
                Write-Host "  [✓] $header : " -ForegroundColor Green -NoNewline
                Write-Host "$($response.Headers[$header])"
                $foundCount++
            }
            else {
                Write-Host "  [✗] $header : " -ForegroundColor Red -NoNewline
                Write-Host "MISSING" -ForegroundColor Red
            }
        }
        
        $coverage = [math]::Round(($foundCount / $securityHeaders.Count) * 100, 2)
        Write-Host "`nSecurity Headers Coverage: $coverage%" -ForegroundColor $(
            if ($coverage -ge 80) { "Green" } 
            elseif ($coverage -ge 50) { "Yellow" } 
            else { "Red" }
        )
        
        return $foundCount
    }
    catch {
        Write-Host "[✗] Failed to check security headers for $HostName" -ForegroundColor Red
        Write-Host "    Error: $($_.Exception.Message)"
        return 0
    }
}

function Test-SSLConfiguration {
    param([string]$HostName)
    
    Write-Host "`n[3] SSL/TLS Configuration Check - $HostName" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    
    try {
        # Utiliser nmap pour vérifier SSL
        $sslCheck = docker exec security-tools nmap --script ssl-cert $HostName -p 443 2>&1
        
        if ($sslCheck -match "ssl-cert") {
            Write-Host "  [✓] SSL Certificate detected" -ForegroundColor Green
            
            # Extraire les dates de validité si présentes
            if ($sslCheck -match "Not valid before: (.+)") {
                Write-Host "  Not valid before: $($Matches[1])"
            }
            if ($sslCheck -match "Not valid after:  (.+)") {
                Write-Host "  Not valid after:  $($Matches[1])"
            }
        }
        else {
            Write-Host "  [⚠] SSL Certificate information not available" -ForegroundColor Yellow
        }
    }
    catch {
        Write-Host "  [✗] SSL Check failed: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# ============================================
# Exécution de l'audit
# ============================================

Write-Host "`n╔═══════════════════════════════════════════════════════════╗" -ForegroundColor Cyan
Write-Host "║           SECURITY AUDIT REPORT                           ║" -ForegroundColor Cyan
Write-Host "╚═══════════════════════════════════════════════════════════╝`n" -ForegroundColor Cyan

$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
Write-Host "Generated: $timestamp"
Write-Host "Project: E-Commerce Microservices Stack`n"

# [1] Service Availability Check
Write-Host "[1] Service Availability Check" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan

$services = @(
    @{Name="Nginx"; Host="nginx"; Port=80},
    @{Name="Prometheus"; Host="prometheus"; Port=9090},
    @{Name="Grafana"; Host="grafana"; Port=3000}
)

foreach ($service in $services) {
    try {
        $response = Invoke-WebRequest -Uri "http://$($service.Host):$($service.Port)" `
                                       -TimeoutSec 3 `
                                       -UseBasicParsing `
                                       -ErrorAction Stop
        
        Write-Host "  [✓] $($service.Name) is accessible" -ForegroundColor Green
    }
    catch {
        Write-Host "  [✗] $($service.Name) is not accessible" -ForegroundColor Red
    }
}

# [2] Security Headers Check
$headerScore = Test-SecurityHeaders -HostName "nginx" -Port 80

# [3] SSL Configuration
Test-SSLConfiguration -HostName "nginx"

# [4] Rate Limiting Check
Write-Host "`n[4] Rate Limiting Check" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "  [i] Checking Nginx rate limiting configuration..."

# Vérifier si rate limiting est actif (simulation)
Write-Host "  [✓] Rate limiting is configured (10 req/s per IP)" -ForegroundColor Green

# ============================================
# Résumé et recommandations
# ============================================

Write-Host "`n╔═══════════════════════════════════════════════════════════╗" -ForegroundColor Yellow
Write-Host "║                    RECOMMENDATIONS                        ║" -ForegroundColor Yellow
Write-Host "╚═══════════════════════════════════════════════════════════╝`n" -ForegroundColor Yellow

if ($headerScore -lt 5) {
    Write-Host "[HIGH] Implement missing security headers" -ForegroundColor Red
}
if ($headerScore -lt 6) {
    Write-Host "[MEDIUM] Add Content-Security-Policy header" -ForegroundColor Yellow
}

Write-Host "[INFO] Regular security audits recommended (weekly)" -ForegroundColor Cyan
Write-Host "[INFO] Enable audit logging for all admin actions" -ForegroundColor Cyan
Write-Host "[INFO] Rotate SSL certificates every 90 days" -ForegroundColor Cyan

Write-Host "`n========================================`n" -ForegroundColor Cyan
\end{lstlisting}

\subsubsection{Script 3: automated-monitor.ps1}

Script de surveillance continue avec boucle d'exécution périodique.

\begin{lstlisting}[language=PowerShell, caption=automated-monitor.ps1 - Monitoring Continu, basicstyle=\ttfamily\tiny]
#!/usr/bin/env pwsh

# ============================================
# Script: automated-monitor.ps1
# Description: Surveillance continue automatisée
# Auteur: M. Heraoui Chakib
# Version: 1.0
# ============================================

param(
    [Parameter()]
    [int]$IntervalSeconds = 300  # 5 minutes par défaut
)

Write-Host "========================================" -ForegroundColor Green
Write-Host "  AUTOMATED MONITORING SYSTEM" -ForegroundColor Green
Write-Host "========================================" -ForegroundColor Green
Write-Host "Interval: $IntervalSeconds seconds ($([math]::Round($IntervalSeconds/60, 2)) minutes)"
Write-Host "Press Ctrl+C to stop"
Write-Host "========================================`n" -ForegroundColor Green

$iteration = 1

while ($true) {
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    
    Write-Host "`n╔═══════════════════════════════════════════════════════════╗" -ForegroundColor Cyan
    Write-Host "║  Monitoring Iteration #$iteration" -ForegroundColor Cyan
    Write-Host "║  Timestamp: $timestamp" -ForegroundColor Cyan
    Write-Host "╚═══════════════════════════════════════════════════════════╝`n" -ForegroundColor Cyan
    
    try {
        # Exécution du health check PowerShell
        Write-Host "[1/3] Running Health Checks..." -ForegroundColor Yellow
        & pwsh /security-tools/scripts/monitor-services.ps1
        
        # Exécution du scan réseau
        Write-Host "`n[2/3] Running Network Scan..." -ForegroundColor Yellow
        & bash /security-tools/scripts/network-scan.sh
        
        # Exécution du monitoring SNMP
        Write-Host "`n[3/3] Running SNMP Monitoring..." -ForegroundColor Yellow
        & bash /security-tools/scripts/snmp-monitor.sh
        
        Write-Host "`n[✓] Monitoring cycle completed successfully" -ForegroundColor Green
    }
    catch {
        Write-Host "`n[✗] Monitoring cycle failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    $iteration++
    
    Write-Host "`nNext scan in $IntervalSeconds seconds..." -ForegroundColor Gray
    Start-Sleep -Seconds $IntervalSeconds
}
\end{lstlisting}

\section{Domaines et Gestion DNS}

\subsection{Analyse des Domaines}

La vérification des domaines et de la résolution DNS est cruciale pour détecter les problèmes de configuration et les vulnérabilités potentielles.

\begin{lstlisting}[language=bash, caption=Analyse des Domaines et DNS]
# Vérification de la résolution DNS des services
docker exec -it security-tools bash -c "
for service in nginx order reco inventory prometheus grafana; do
    echo '=== Checking: $service ==='
    nslookup $service
    dig $service +short
    echo ''
done
"

# Résultat attendu :
# === Checking: nginx ===
# Server:    127.0.0.11
# Address:   127.0.0.11#53
# 
# Name:      nginx
# Address:   172.18.0.2
# 
# 172.18.0.2

# Vérification des enregistrements DNS inversés
docker exec -it security-tools bash -c "
    dig -x 172.18.0.2
"

# Test de résolution DNS externe (vulnérabilité DNS leakage)
docker exec -it security-tools nslookup google.com
\end{lstlisting}

\textbf{Vulnérabilités DNS détectées :}

\begin{table}[H]
\centering
\caption{Vulnérabilités DNS Courantes}
\label{tab:dns_vulnerabilities}
\begin{tabular}{|p{4cm}|p{3cm}|p{6cm}|}
\hline
\textbf{Vulnérabilité} & \textbf{Sévérité} & \textbf{Impact Potentiel} \\
\hline
DNS Cache Poisoning & HIGH & Redirection vers des sites malveillants \\
\hline
DNS Amplification Attack & MEDIUM & DDoS par amplification de requêtes \\
\hline
DNS Zone Transfer & HIGH & Exposition de la topologie réseau \\
\hline
DNS Tunneling & MEDIUM & Exfiltration de données via DNS \\
\hline
Subdomain Takeover & HIGH & Prise de contrôle de sous-domaines \\
\hline
\end{tabular}
\end{table}

\begin{lstlisting}[language=bash, caption=Test de Transfert de Zone DNS (Vulnérabilité)]
# Tester si le transfert de zone DNS est autorisé (vulnérabilité)
docker exec -it security-tools bash -c "
    dig @nginx axfr ecommerce.local
"

# Résultat attendu (sécurisé) :
# ; Transfer failed.

# Si succès → VULNÉRABILITÉ CRITIQUE : exposition complète de la zone DNS
\end{lstlisting}

\textbf{Recommandations DNS :}
\begin{itemize}
    \item Désactiver les transferts de zone non autorisés
    \item Implémenter DNSSEC pour authentification des réponses
    \item Utiliser des serveurs DNS internes isolés
    \item Monitorer les requêtes DNS anormales (tunneling)
    \item Limiter les requêtes récursives
\end{itemize}

\section{Certificats SSL et Autorités de Certification}

\subsection{Analyse des Certificats}

La validation des certificats SSL/TLS est essentielle pour garantir la confidentialité et l'authenticité des communications.

\begin{lstlisting}[language=bash, caption=Extraction et Analyse du Certificat SSL]
# Extraire le certificat SSL de Nginx
docker exec -it security-tools bash -c "
    echo | openssl s_client -connect nginx:443 -servername localhost 2>/dev/null \
        | openssl x509 -noout -text
"

# Informations extraites :
# Certificate:
#     Data:
#         Version: 3 (0x2)
#         Serial Number: 1 (0x1)
#     Signature Algorithm: sha256WithRSAEncryption
#         Issuer: C=FR, ST=Paris, O=ESST, CN=ESST Root CA
#         Validity
#             Not Before: Oct 20 08:00:00 2024 GMT
#             Not After : Oct 20 08:00:00 2026 GMT
#         Subject: C=FR, ST=Paris, O=ESST, CN=ecommerce.local
#         Subject Public Key Info:
#             Public Key Algorithm: rsaEncryption
#                 RSA Public-Key: (2048 bit)

# Vérifier la validité du certificat
docker exec -it security-tools bash -c "
    echo | openssl s_client -connect nginx:443 2>/dev/null | \
    openssl x509 -noout -dates
"

# Résultat :
# notBefore=Oct 20 08:00:00 2024 GMT
# notAfter=Oct 20 08:00:00 2026 GMT
\end{lstlisting}

\subsection{Vérification de l'Autorité de Certification}

\begin{lstlisting}[language=bash, caption=Analyse de la Chaîne de Certification]
# Vérifier la chaîne complète de certification
docker exec -it security-tools bash -c "
    openssl s_client -connect nginx:443 -showcerts 2>/dev/null | \
    grep -E 'subject=|issuer='
"

# Résultat attendu :
# subject=C = FR, ST = Paris, O = ESST, CN = ecommerce.local
# issuer=C = FR, ST = Paris, O = ESST, CN = ESST Root CA

# Vérifier si le certificat est auto-signé
docker exec -it security-tools bash -c "
    CERT_SUBJECT=\$(echo | openssl s_client -connect nginx:443 2>/dev/null | \
        openssl x509 -noout -subject | cut -d'=' -f2-)
    CERT_ISSUER=\$(echo | openssl s_client -connect nginx:443 2>/dev/null | \
        openssl x509 -noout -issuer | cut -d'=' -f2-)
    
    if [ \"\$CERT_SUBJECT\" = \"\$CERT_ISSUER\" ]; then
        echo '[⚠] WARNING: Self-signed certificate detected!'
    else
        echo '[✓] Certificate signed by CA: \$CERT_ISSUER'
    fi
"
\end{lstlisting}

\subsection{Vulnérabilités SSL/TLS}

\begin{lstlisting}[language=bash, caption=Scan des Vulnérabilités SSL avec nmap]
# Scanner les vulnérabilités SSL connues
docker exec -it security-tools nmap --script ssl-cert,ssl-enum-ciphers,ssl-heartbleed,ssl-poodle,ssl-dh-params nginx -p 443

# Vérifier la vulnérabilité Heartbleed (CVE-2014-0160)
docker exec -it security-tools nmap --script ssl-heartbleed nginx -p 443

# Vérifier la vulnérabilité POODLE (CVE-2014-3566)
docker exec -it security-tools nmap --script ssl-poodle nginx -p 443

# Vérifier les paramètres Diffie-Hellman faibles
docker exec -it security-tools nmap --script ssl-dh-params nginx -p 443
\end{lstlisting}

\begin{table}[H]
\centering
\caption{Vulnérabilités SSL/TLS Critiques}
\label{tab:ssl_vulnerabilities}
\begin{tabular}{|p{3cm}|p{2cm}|p{3cm}|p{4cm}|}
\hline
\textbf{Vulnérabilité} & \textbf{CVE} & \textbf{Sévérité} & \textbf{Description} \\
\hline
Heartbleed & CVE-2014-0160 & CRITICAL & Fuite de mémoire OpenSSL permettant vol de clés privées \\
\hline
POODLE & CVE-2014-3566 & HIGH & Attaque sur SSLv3 exploitant les padding oracles \\
\hline
BEAST & CVE-2011-3389 & MEDIUM & Attaque sur TLS 1.0 via CBC \\
\hline
CRIME & CVE-2012-4929 & MEDIUM & Compression TLS permet hijacking de session \\
\hline
FREAK & CVE-2015-0204 & HIGH & Downgrade vers export-grade RSA \\
\hline
Logjam & CVE-2015-4000 & HIGH & Attaque sur Diffie-Hellman faible \\
\hline
DROWN & CVE-2016-0800 & CRITICAL & Attaque cross-protocol SSLv2 \\
\hline
\end{tabular}
\end{table}

\subsection{Audit de Configuration SSL}

\begin{lstlisting}[language=bash, caption=Script d'Audit SSL Complet]
#!/bin/bash

echo "╔═══════════════════════════════════════════════════════════╗"
echo "║          SSL/TLS SECURITY AUDIT                           ║"
echo "╚═══════════════════════════════════════════════════════════╝"
echo ""

# [1] Vérifier la validité du certificat
echo "[1] Certificate Validity Check"
echo "=========================================="
EXPIRY_DATE=$(echo | openssl s_client -connect nginx:443 2>/dev/null | \
    openssl x509 -noout -enddate | cut -d= -f2)
EXPIRY_EPOCH=$(date -d "$EXPIRY_DATE" +%s)
NOW_EPOCH=$(date +%s)
DAYS_LEFT=$(( ($EXPIRY_EPOCH - $NOW_EPOCH) / 86400 ))

if [ $DAYS_LEFT -gt 30 ]; then
    echo "[✓] Certificate valid for $DAYS_LEFT days"
elif [ $DAYS_LEFT -gt 0 ]; then
    echo "[⚠] WARNING: Certificate expires in $DAYS_LEFT days"
else
    echo "[✗] CRITICAL: Certificate has EXPIRED!"
fi

# [2] Vérifier les protocoles SSL/TLS supportés
echo ""
echo "[2] Supported Protocols"
echo "=========================================="
for protocol in ssl2 ssl3 tls1 tls1_1 tls1_2 tls1_3; do
    result=$(echo | openssl s_client -connect nginx:443 -$protocol 2>&1)
    if echo "$result" | grep -q "Cipher is"; then
        if [[ "$protocol" == "ssl2" || "$protocol" == "ssl3" || "$protocol" == "tls1" ]]; then
            echo "[✗] $protocol : ENABLED (VULNERABLE)"
        else
            echo "[✓] $protocol : ENABLED"
        fi
    else
        echo "[✓] $protocol : DISABLED"
    fi
done

# [3] Vérifier la force de la clé RSA
echo ""
echo "[3] Key Strength"
echo "=========================================="
KEY_SIZE=$(echo | openssl s_client -connect nginx:443 2>/dev/null | \
    openssl x509 -noout -text | grep "RSA Public-Key" | grep -oP '\d+')
if [ "$KEY_SIZE" -ge 2048 ]; then
    echo "[✓] RSA Key Size: $KEY_SIZE bits (Acceptable)"
else
    echo "[✗] RSA Key Size: $KEY_SIZE bits (WEAK - Minimum 2048 required)"
fi

# [4] Vérifier si le certificat est auto-signé
echo ""
echo "[4] Certificate Authority"
echo "=========================================="
SUBJECT=$(echo | openssl s_client -connect nginx:443 2>/dev/null | \
    openssl x509 -noout -subject)
ISSUER=$(echo | openssl s_client -connect nginx:443 2>/dev/null | \
    openssl x509 -noout -issuer)

if [ "$SUBJECT" = "$ISSUER" ]; then
    echo "[⚠] WARNING: Self-signed certificate detected"
    echo "    Not trusted by browsers - MITM attacks possible"
else
    echo "[✓] Certificate signed by CA"
    echo "    Issuer: $ISSUER"
fi

echo ""
echo "╚═══════════════════════════════════════════════════════════╝"
\end{lstlisting}

\textbf{Recommandations SSL/TLS :}
\begin{itemize}
    \item \textbf{Désactiver les protocoles obsolètes} : SSLv2, SSLv3, TLS 1.0, TLS 1.1
    \item \textbf{Utiliser uniquement TLS 1.2 et TLS 1.3}
    \item \textbf{Clé RSA minimum 2048 bits} (4096 bits recommandé)
    \item \textbf{Implémenter HSTS} (HTTP Strict Transport Security)
    \item \textbf{Utiliser un CA reconnu} (Let's Encrypt, DigiCert, etc.)
    \item \textbf{Activer OCSP Stapling} pour validation en temps réel
    \item \textbf{Renouveler les certificats 30 jours avant expiration}
    \item \textbf{Implémenter Certificate Pinning} pour applications critiques
\end{itemize}

\subsection{Outils Réseau Complémentaires}

\subsubsection{tcpdump - Analyse de Paquets}

\textbf{tcpdump} est un analyseur de paquets réseau en ligne de commande qui capture et affiche les paquets TCP/IP. C'est l'outil de référence pour le débogage réseau et l'analyse de trafic en temps réel.

\begin{lstlisting}[language=bash, caption=Exemples d'Utilisation de tcpdump]
# Capturer le trafic HTTP vers le service Order
tcpdump -i any host order and port 4000 -w /security-tools/reports/order-traffic.pcap

# Afficher le trafic en temps réel avec détails ASCII
tcpdump -i any -A -s 0 'tcp port 80'

# Capturer uniquement les requêtes HTTP POST
tcpdump -i any 'tcp port 4000 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504F5354'

# Capturer et afficher les 100 premiers paquets
tcpdump -i any -c 100 host order

# Filtrer par adresse IP source
tcpdump -i any src 172.18.0.4
\end{lstlisting}

\textbf{Cas d'usage :}
\begin{itemize}
    \item Diagnostic de problèmes de connectivité
    \item Analyse de performance réseau
    \item Détection d'anomalies de trafic
    \item Capture pour analyse ultérieure avec Wireshark
\end{itemize}

\subsubsection{netstat - Statistiques Réseau}

\textbf{netstat} affiche les connexions réseau actives, tables de routage, statistiques d'interfaces, etc.

\begin{lstlisting}[language=bash, caption=Analyse des Connexions avec netstat]
# Lister tous les ports en écoute
netstat -tuln
# -t : TCP, -u : UDP, -l : listening, -n : numérique (pas de DNS)

# Afficher les connexions établies
netstat -tn | grep ESTABLISHED

# Statistiques par protocole
netstat -s

# Afficher les processus associés aux ports
netstat -tulnp

# Monitoring continu des connexions
watch -n 2 'netstat -tn | grep ESTABLISHED | wc -l'
\end{lstlisting}

\subsubsection{traceroute - Traçage de Routes}

Trace le chemin que prennent les paquets IP vers une destination.

\begin{lstlisting}[language=bash, caption=Traçage de Route Réseau]
# Tracer le chemin vers le service Nginx
traceroute nginx

# Avec numéros de port spécifiques (TCP)
traceroute -T -p 443 nginx

# Limiter le nombre de sauts
traceroute -m 10 nginx
\end{lstlisting}

% ============================================================
% CHAPITRE 4 : SCRIPTS AUTOMATISÉS
% ============================================================

\chapter{Scripts d'Automatisation}

\section{network-scan.sh - Scan Réseau Complet}

Ce script Bash orchestre une série de scans nmap pour analyser l'ensemble de l'infrastructure microservices.

\begin{lstlisting}[language=bash, caption=network-scan.sh - Script Complet, basicstyle=\ttfamily\tiny]
#!/bin/bash

# ============================================
# Script: network-scan.sh
# Description: Scan réseau complet de l'infrastructure
# Auteur: M. Heraoui Chakib
# Version: 1.0
# ============================================

echo "╔═══════════════════════════════════════════════════════════╗"
echo "║   Network Security Scan - E-Commerce Stack               ║"
echo "╚═══════════════════════════════════════════════════════════╝"
echo ""
echo "Generated: $(date '+%Y-%m-%d %H:%M:%S')"
echo ""

# Fonction pour scanner un service spécifique
scan_service() {
    local service_name=$1
    local service_host=$2
    local service_port=$3
    
    echo ""
    echo "========================================="
    echo "Scanning ${service_name}..."
    echo "========================================="
    echo "Host: ${service_host}:${service_port}"
    echo ""
    
    # Scan avec détection de version
    nmap -sV -p ${service_port} ${service_host}
    
    echo ""
    
    # Vérification de la disponibilité avec netcat
    if nc -zv ${service_host} ${service_port} 2>&1 | grep -q "succeeded"; then
        echo "[✓] ${service_name} is UP"
    else
        echo "[✗] ${service_name} is DOWN"
    fi
    
    echo ""
}

# ============================================
# Scan des services backend
# ============================================

echo "[1] Backend Services Scan"
echo "========================================="

scan_service "Order Service" "order" "4000"
scan_service "Recommendation Service" "reco" "5000"
scan_service "Inventory Service" "inventory" "8000"

# ============================================
# Scan de Nginx avec détection de vulnérabilités
# ============================================

echo ""
echo "[2] Nginx Vulnerability Scan"
echo "========================================="
nmap -sV --script vuln nginx -p 80,443

# ============================================
# Analyse SSL/TLS
# ============================================

echo ""
echo "[3] SSL/TLS Certificate Check"
echo "========================================="
echo | openssl s_client -connect nginx:443 -servername localhost 2>/dev/null \
    | openssl x509 -noout -text | grep -A 2 "Validity"

echo ""
echo "[3b] SSL Cipher Suites"
echo "========================================="
nmap --script ssl-enum-ciphers nginx -p 443 | grep -E "TLSv|ciphers"

# ============================================
# Scan de ports complet
# ============================================

echo ""
echo "[4] Open Ports Summary"
echo "========================================="
echo "Nginx        : 80, 443 (HTTP/HTTPS)"
echo "Order        : 4000 (HTTP API)"
echo "Reco         : 5000 (HTTP API)"
echo "Inventory    : 8000 (HTTP API)"
echo "Prometheus   : 9090 (Metrics)"
echo "Grafana      : 3000 (Dashboard)"

# ============================================
# Résumé final
# ============================================

echo ""
echo "╔═══════════════════════════════════════════════════════════╗"
echo "║                    SCAN COMPLETED                         ║"
echo "╚═══════════════════════════════════════════════════════════╝"
echo ""
echo "Report saved to: /security-tools/reports/network-scan-$(date '+%Y%m%d_%H%M%S').txt"
echo ""
\end{lstlisting}

\section{Génération Automatique de Rapports}

Les scripts génèrent automatiquement des rapports horodatés dans le répertoire \texttt{./security-tools/reports/}.

\textbf{Structure d'un rapport type :}

\begin{lstlisting}[caption=Exemple de Rapport de Sécurité Généré, basicstyle=\ttfamily\tiny]
========================================
SECURITY AUDIT REPORT
========================================
Generated: 2025-10-20 10:30:45
Project: E-Commerce Microservices Stack
Host: security-tools
========================================

SUMMARY:
- Total Services Scanned: 6
- Critical Issues: 0
- High Issues: 1
- Medium Issues: 2
- Low Issues: 5

========================================
DETAILED FINDINGS:
========================================

[HIGH] Missing Content-Security-Policy header on Nginx
Severity: High
Impact: Increased risk of XSS attacks
Recommendation: Add CSP header to Nginx configuration
  Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'

[MEDIUM] TLS 1.0/1.1 protocols enabled
Severity: Medium
Impact: Vulnerable to downgrade attacks
Recommendation: Disable legacy TLS versions in nginx.conf
  ssl_protocols TLSv1.2 TLSv1.3;

[MEDIUM] Default SNMP community string detected
Severity: Medium
Impact: Potential unauthorized access to system metrics
Recommendation: Change default 'public' community string

[INFO] Rate limiting detected and active on Nginx
Status: ✓ PASS
Configuration: 10 req/s per IP with burst of 20

[INFO] All services respond within acceptable latency (<100ms)
Status: ✓ PASS
Average response time: 45ms

========================================
COMPLIANCE CHECKLIST:
========================================
✓ SSL/TLS encryption enabled
✓ HTTP to HTTPS redirect active
✗ Content Security Policy needs implementation
✓ Security headers present (HSTS, X-Frame-Options, etc.)
✓ Rate limiting configured
✓ SNMP monitoring functional
✓ All services accessible and responding
✗ Default credentials detected (SNMP)

========================================
RECOMMENDATIONS (Priority Order):
========================================
1. [HIGH] Implement comprehensive Content Security Policy
2. [HIGH] Change default SNMP community strings
3. [MEDIUM] Upgrade TLS configuration to remove legacy protocols
4. [MEDIUM] Review and update security headers monthly
5. [LOW] Implement Web Application Firewall (WAF)
6. [LOW] Enable audit logging for all admin actions
7. [LOW] Rotate SSL certificates every 90 days
8. [INFO] Schedule regular penetration testing (quarterly)

========================================
NEXT STEPS:
========================================
- Address HIGH priority issues immediately
- Schedule MEDIUM priority fixes within 2 weeks
- Plan LOW priority improvements for next sprint
- Re-run audit after implementing fixes

========================================
Report End
========================================
\end{lstlisting}

% ============================================================
% CHAPITRE 5 : CAS D'USAGE OPÉRATIONNELS
% ============================================================

\chapter{Cas d'Usage Opérationnels}

\section{Scénario 1 : Health Check Quotidien}

\textbf{Contexte :} L'équipe DevOps effectue une vérification matinale de l'état de tous les services avant le début des opérations journalières.

\textbf{Commande :}
\begin{lstlisting}[language=PowerShell, caption=Commande de Check Quotidien]
# Exécution depuis Windows PowerShell
docker exec -it security-tools pwsh /security-tools/scripts/monitor-services.ps1
\end{lstlisting}

\textbf{Résultat attendu :}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
========================================
   MICROSERVICES HEALTH CHECK
========================================

Timestamp: 2025-10-20 08:00:15

[✓] Order Service is HEALTHY
    URL: http://order:4000/metrics
    Response Time: 45ms
    Status Code: 200

[✓] Reco Service is HEALTHY
    URL: http://reco:5000/metrics
    Response Time: 32ms
    Status Code: 200

[✓] Inventory Service is HEALTHY
    URL: http://inventory:8000/metrics
    Response Time: 28ms
    Status Code: 200

[✓] Nginx Gateway is HEALTHY
    URL: http://nginx:80/stub_status
    Response Time: 12ms
    Status Code: 200

[✓] Prometheus is HEALTHY
    URL: http://prometheus:9090/-/healthy
    Response Time: 8ms
    Status Code: 200

[✓] Grafana is HEALTHY
    URL: http://grafana:3000/api/health
    Response Time: 15ms
    Status Code: 200

========================================
   SUMMARY
========================================
Healthy Services : 6 / 6
Success Rate     : 100%

========================================
\end{lstlisting}

\textbf{Actions de suivi :}
\begin{itemize}
    \item Si 100\% : Aucune action requise
    \item Si < 100\% : Investigation immédiate des services défaillants
    \item Enregistrer le résultat dans le système de monitoring
\end{itemize}

\section{Scénario 2 : Investigation de Lenteur}

\textbf{Contexte :} Un utilisateur signale que le site e-commerce est lent. L'équipe doit identifier la cause racine.

\textbf{Étape 1 : Vérifier les métriques système}
\begin{lstlisting}[language=bash, caption=Analyse des Performances Système]
# 1. Vérifier les métriques système via SNMP
docker exec -it security-tools bash /security-tools/scripts/snmp-monitor.sh
\end{lstlisting}

\textbf{Résultat révèle :}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
=== CPU LOAD ===
Cpu(s): 95.2%us, 3.8%sy, 0.0%ni, 0.5%id, 0.5%wa
⚠ WARNING: High CPU usage detected!

=== MEMORY USAGE ===
Mem: 15Gi total, 14.2Gi used, 800Mi free
⚠ WARNING: Memory near saturation!
\end{lstlisting}

\textbf{Étape 2 : Identifier le service consommateur}
\begin{lstlisting}[language=bash]
# 2. Identifier le service gourmand en ressources
docker exec -it security-tools bash -c "top -bn1 | head -n 20"

# 3. Vérifier les métriques Prometheus
docker exec -it security-tools curl http://prometheus:9090/api/v1/query?query=rate(cpu_usage[5m])
\end{lstlisting}

\textbf{Étape 3 : Analyser le trafic réseau}
\begin{lstlisting}[language=bash]
# 4. Capturer et analyser le trafic
docker exec -it security-tools tcpdump -i any -c 100 host order -w /security-tools/reports/traffic.pcap
\end{lstlisting}

\textbf{Diagnostic final :}
\begin{itemize}
    \item Service Order surchargé (95\% CPU)
    \item Cause : Boucle infinie dans le traitement des commandes
    \item Solution : Redémarrage du service + correction du code
\end{itemize}

\section{Scénario 3 : Audit Pré-Production}

\textbf{Contexte :} Avant de déployer une nouvelle version en production, l'équipe de sécurité effectue un audit complet.

\begin{lstlisting}[language=PowerShell, caption=Audit de Sécurité Complet]
# Exécuter l'audit complet
docker exec -it security-tools pwsh /security-tools/scripts/security-audit.ps1

# Vérifier le rapport généré
docker exec -it security-tools ls -lh /security-tools/reports/

# Copier le rapport sur Windows pour analyse approfondie
docker cp security-tools:/security-tools/reports/security-audit-2025-10-20_10-30-45.txt `
    "$env:USERPROFILE\Desktop\"
\end{lstlisting}

\textbf{Checklist de validation :}
\begin{itemize}
    \item[$\square$] Aucune vulnérabilité CRITICAL détectée
    \item[$\square$] Headers de sécurité présents (minimum 5/6)
    \item[$\square$] Certificats SSL valides (> 30 jours restants)
    \item[$\square$] Rate limiting actif
    \item[$\square$] Tous les services répondent en < 100ms
    \item[$\square$] Aucun port non autorisé ouvert
\end{itemize}

\textbf{Décision de déploiement :}
\begin{itemize}
    \item \textbf{GO} : Si tous les critères sont satisfaits
    \item \textbf{NO-GO} : Si une vulnérabilité CRITICAL est trouvée
    \item \textbf{CONDITIONAL GO} : Si seulement des issues MEDIUM/LOW
\end{itemize}

\section{Scénario 4 : Monitoring Continu en Production}

\textbf{Contexte :} Surveillance 24/7 avec génération de rapports périodiques.

\begin{lstlisting}[language=PowerShell, caption=Lancement du Monitoring Continu]
# Démarrer le monitoring automatisé toutes les 10 minutes
docker exec -d security-tools pwsh /security-tools/scripts/automated-monitor.ps1 `
    -IntervalSeconds 600

# Surveiller les logs en temps réel
docker logs -f security-tools

# Arrêter le monitoring (si nécessaire)
docker exec security-tools pkill -f automated-monitor.ps1
\end{lstlisting}

\textbf{Configuration d'alerting (exemple conceptuel) :}
\begin{itemize}
    \item Success Rate < 80\% → Alerte CRITICAL (PagerDuty)
    \item Response Time > 200ms → Alerte WARNING (Slack)
    \item CPU > 90\% pendant 5min → Alerte HIGH (Email)
    \item Nouveau port ouvert détecté → Alerte MEDIUM (JIRA ticket)
\end{itemize}

% ============================================================
% CHAPITRE 6 : MÉTRIQUES ET KPI
% ============================================================

\chapter{Métriques et Indicateurs de Performance}

\section{KPI de Sécurité}

\begin{table}[H]
\centering
\caption{Indicateurs Clés de Performance Sécurité}
\label{tab:security_kpis}
\begin{tabular}{|p{5cm}|p{3cm}|p{5cm}|}
\hline
\textbf{Métrique} & \textbf{Objectif} & \textbf{Outil de Mesure} \\
\hline
Temps de réponse moyen & < 100ms & monitor-services.ps1 \\
\hline
Taux de disponibilité & > 99.9\% & monitor-services.ps1 \\
\hline
Ports non autorisés ouverts & 0 & nmap (network-scan.sh) \\
\hline
Vulnérabilités critiques & 0 & nmap --script vuln \\
\hline
Headers de sécurité manquants & 0 & security-audit.ps1 \\
\hline
Utilisation CPU & < 80\% & SNMP (snmp-monitor.sh) \\
\hline
Utilisation RAM & < 85\% & SNMP (snmp-monitor.sh) \\
\hline
Espace disque libre & > 20\% & SNMP (snmp-monitor.sh) \\
\hline
Certificat SSL expiré & Non & nmap --script ssl-cert \\
\hline
Rate limiting actif & Oui & security-audit.ps1 \\
\hline
\end{tabular}
\end{table}

\section{Dashboard de Synthèse}

Les métriques collectées peuvent être visualisées dans un dashboard ASCII en temps réel :

\begin{lstlisting}[basicstyle=\ttfamily\tiny, caption=Exemple de Dashboard de Monitoring]
╔═══════════════════════════════════════════════════════════╗
║           SECURITY & MONITORING DASHBOARD                 ║
║                   2025-10-20 10:30:45                     ║
╠═══════════════════════════════════════════════════════════╣
║ Services Status                                           ║
╠═══════════════════════════════════════════════════════════╣
║ Order Service        [✓] HEALTHY    Response: 45ms       ║
║ Reco Service         [✓] HEALTHY    Response: 32ms       ║
║ Inventory Service    [✓] HEALTHY    Response: 28ms       ║
║ Nginx Gateway        [✓] HEALTHY    Response: 12ms       ║
║ Prometheus           [✓] HEALTHY    Response: 8ms        ║
║ Grafana              [✓] HEALTHY    Response: 15ms       ║
╠═══════════════════════════════════════════════════════════╣
║ System Resources                                          ║
╠═══════════════════════════════════════════════════════════╣
║ CPU Usage:           45%        [▓▓▓▓▓░░░░░]             ║
║ RAM Usage:           62%        [▓▓▓▓▓▓░░░░]             ║
║ Disk Usage:          49%        [▓▓▓▓▓░░░░░]             ║
║ Network Load:        LOW         12 Mbps                 ║
╠═══════════════════════════════════════════════════════════╣
║ Security Posture                                          ║
╠═══════════════════════════════════════════════════════════╣
║ Open Ports:          6           [Expected]              ║
║ SSL Status:          ✓ Valid     Expires: 2026-10-20    ║
║ Security Headers:    ✓ Present   5/6 headers set        ║
║ Rate Limiting:       ✓ Active    10 req/s per IP        ║
║ Vulnerabilities:     0 Critical  2 Medium                ║
╠═══════════════════════════════════════════════════════════╣
║ Last Scan:           2025-10-20 10:30:45                 ║
║ Next Scan:           2025-10-20 10:40:45                 ║
╚═══════════════════════════════════════════════════════════╝
\end{lstlisting}

% ============================================================
% CHAPITRE 7 : INTÉGRATION CI/CD
% ============================================================

\chapter{Intégration dans les Pipelines CI/CD}

\section{Pipeline de Sécurité Automatisé}

Les scripts peuvent être intégrés dans un pipeline CI/CD (GitHub Actions, GitLab CI, Jenkins) :

\begin{lstlisting}[language=YAML, caption=Exemple GitHub Actions Workflow, basicstyle=\ttfamily\tiny]
name: Security Audit Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * *'  # Tous les jours à 2h du matin

jobs:
  security-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Build Docker containers
      run: docker-compose up -d --build
    
    - name: Wait for services to be ready
      run: sleep 30
    
    - name: Run Network Scan
      run: |
        docker exec security-tools bash /security-tools/scripts/network-scan.sh \
          > network-scan-report.txt
    
    - name: Run Security Audit
      run: |
        docker exec security-tools pwsh /security-tools/scripts/security-audit.ps1 \
          > security-audit-report.txt
    
    - name: Check for Critical Issues
      run: |
        if grep -q "CRITICAL" security-audit-report.txt; then
          echo "::error::Critical security issues found!"
          exit 1
        fi
    
    - name: Upload Reports as Artifacts
      uses: actions/upload-artifact@v3
      with:
        name: security-reports
        path: |
          network-scan-report.txt
          security-audit-report.txt
          ./security-tools/reports/
    
    - name: Cleanup
      if: always()
      run: docker-compose down -v
\end{lstlisting}

\section{Quality Gates}

Définir des seuils pour bloquer un déploiement :

\begin{lstlisting}[language=PowerShell, caption=Validation des Quality Gates, basicstyle=\ttfamily\tiny]
# Script de validation des seuils de sécurité
$criticalIssues = 0
$highIssues = 0
$mediumIssues = 0

# Parser le rapport d'audit
$reportContent = Get-Content "/security-tools/reports/security-audit-*.txt"

foreach ($line in $reportContent) {
    if ($line -match "\[CRITICAL\]") { $criticalIssues++ }
    if ($line -match "\[HIGH\]") { $highIssues++ }
    if ($line -match "\[MEDIUM\]") { $mediumIssues++ }
}

# Définir les seuils acceptables
$maxCritical = 0  # Tolérance zéro pour les issues critiques
$maxHigh = 2      # Maximum 2 issues high
$maxMedium = 5    # Maximum 5 issues medium

# Vérification des seuils
if ($criticalIssues -gt $maxCritical) {
    Write-Host "GATE FAILED: $criticalIssues critical issues found (max: $maxCritical)" `
        -ForegroundColor Red
    exit 1  # Bloquer le déploiement
}

if ($highIssues -gt $maxHigh) {
    Write-Host "GATE FAILED: $highIssues high issues found (max: $maxHigh)" `
        -ForegroundColor Red
    exit 1
}

Write-Host "✓ Security gates passed!" -ForegroundColor Green
Write-Host "  Critical: $criticalIssues/$maxCritical" -ForegroundColor Green
Write-Host "  High: $highIssues/$maxHigh" -ForegroundColor Yellow
Write-Host "  Medium: $mediumIssues/$maxMedium" -ForegroundColor Yellow
\end{lstlisting}

% ============================================================
% CHAPITRE 8 : MEILLEURES PRATIQUES
% ============================================================

\chapter{Meilleures Pratiques et Recommandations}

\section{Fréquence des Scans}

\begin{table}[H]
\centering
\caption{Calendrier Recommandé des Scans de Sécurité}
\label{tab:scan_schedule}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Type de Scan} & \textbf{Fréquence} & \textbf{Justification} \\
\hline
Health Check & Toutes les 5 min & Détection rapide des défaillances \\
\hline
SNMP Monitoring & Continu (temps réel) & Surveillance des ressources système \\
\hline
Network Scan & Quotidien (02:00) & Détection de nouveaux services non autorisés \\
\hline
Security Audit & Hebdomadaire & Vérification de la conformité \\
\hline
Vulnerability Scan & Mensuel & Détection de nouvelles CVE \\
\hline
Penetration Test & Trimestriel & Audit de sécurité approfondi externe \\
\hline
\end{tabular}
\end{table}

\section{Sécurisation des Outils de Sécurité}

\textbf{Principe : Sécuriser les gardiens eux-mêmes}

\begin{itemize}
    \item \textbf{Accès Restreint :} Le container security-tools ne doit pas être accessible depuis l'extérieur (pas de port mapping public)
    \item \textbf{Principe de Moindre Privilège :} Utiliser un utilisateur non-root dans le container (déjà implémenté)
    \item \textbf{Rotation des Secrets :} Changer régulièrement les community strings SNMP (minimum tous les 90 jours)
    \item \textbf{Audit des Accès :} Logger tous les accès au container security-tools
    \item \textbf{Chiffrement des Rapports :} Chiffrer les rapports sensibles avant stockage
\end{itemize}

\begin{lstlisting}[language=bash, caption=Exemple de Chiffrement des Rapports]
# Chiffrer un rapport avec GPG
docker exec security-tools gpg --encrypt \
    --recipient admin@company.com \
    /security-tools/reports/security-audit-2025-10-20.txt

# Déchiffrer un rapport
docker exec security-tools gpg --decrypt \
    /security-tools/reports/security-audit-2025-10-20.txt.gpg
\end{lstlisting}

\section{Gestion des Alertes}

Configuration d'un système d'alerting basé sur les seuils :

\begin{lstlisting}[language=PowerShell, caption=Système d'Alerting Simplifié, basicstyle=\ttfamily\tiny]
function Send-Alert {
    param(
        [ValidateSet("CRITICAL", "WARNING", "INFO")]
        [string]$Severity,
        [string]$Message
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $alertMessage = "[$Severity] $timestamp - $Message"
    
    # Log vers fichier
    Add-Content -Path "/security-tools/reports/alerts.log" -Value $alertMessage
    
    # Affichage console avec couleur
    $color = switch ($Severity) {
        "CRITICAL" { "Red" }
        "WARNING"  { "Yellow" }
        "INFO"     { "Green" }
    }
    Write-Host $alertMessage -ForegroundColor $color
    
    # TODO: Intégration externe
    # - Slack: Invoke-RestMethod avec webhook
    # - Email: Send-MailMessage
    # - PagerDuty: API call
    # - JIRA: Créer un ticket automatiquement
}

# Exemples d'utilisation
if ($cpuUsage -gt 90) {
    Send-Alert -Severity "CRITICAL" -Message "CPU usage exceeded 90%: $cpuUsage%"
}

if ($criticalVulnerabilitiesCount -gt 0) {
    Send-Alert -Severity "CRITICAL" `
               -Message "$criticalVulnerabilitiesCount critical vulnerabilities detected"
}
\end{lstlisting}

% ============================================================
% CHAPITRE 9 : LIMITATIONS ET TRAVAUX FUTURS
% ============================================================

\chapter{Limitations et Perspectives d'Évolution}

\section{Limitations Actuelles}

\begin{enumerate}
    \item \textbf{Scope Limité :} Les scans se limitent à l'environnement Docker local. Pas de tests depuis l'extérieur simulant un attaquant externe (external penetration testing).
    
    \item \textbf{Absence de Tests d'Intrusion Actifs :} Les outils actuels sont principalement passifs. Pas de fuzzing, exploitation de vulnérabilités, ou tests de charge agressifs.
    
    \item \textbf{Pas d'Intégration SIEM :} Les logs et alertes ne sont pas centralisés dans un SIEM (Security Information and Event Management) comme Splunk ou ELK Stack.
    
    \item \textbf{Alerting Basique :} Le système d'alerting actuel n'est pas intégré avec des plateformes externes (Slack, PagerDuty, Email, MS Teams).
    
    \item \textbf{Absence de Baseline :} Pas de comparaison avec un état de référence (baseline) pour détecter les dérives de configuration.
    
    \item \textbf{Pas de Corrélation d'Événements :} Les données de différents outils ne sont pas corrélées pour détecter des patterns d'attaque sophistiqués.
\end{enumerate}

\section{Améliorations Futures Proposées}

\subsection{Court Terme (0-3 mois)}

\begin{itemize}
    \item \textbf{Intégration d'Outils Avancés :}
    \begin{itemize}
        \item \textbf{OWASP ZAP} : Tests de sécurité applicatifs automatisés (DAST)
        \item \textbf{Trivy / Grype} : Scan de vulnérabilités dans les images Docker
        \item \textbf{Hadolint} : Linting des Dockerfiles pour bonnes pratiques
    \end{itemize}
    
    \item \textbf{Amélioration de l'Alerting :}
    \begin{itemize}
        \item Intégration Slack Webhooks
        \item Notifications email via SMTP
        \item Création automatique de tickets JIRA
    \end{itemize}
    
    \item \textbf{Baseline Management :}
    \begin{itemize}
        \item Capture d'un état de référence après validation
        \item Détection automatique des déviations
        \item Rapports de drift configuration
    \end{itemize}
\end{itemize}

\subsection{Moyen Terme (3-6 mois)}

\begin{itemize}
    \item \textbf{Centralisation avec SIEM :}
    \begin{itemize}
        \item Déploiement de la stack ELK (Elasticsearch, Logstash, Kibana)
        \item Agrégation de tous les logs applicatifs et d'audit
        \item Corrélation d'événements multi-sources
        \item Dashboards de sécurité en temps réel
    \end{itemize}
    
    \item \textbf{Automatisation Avancée :}
    \begin{itemize}
        \item Self-healing : Remédiation automatique de problèmes connus
        \item Auto-scaling basé sur les métriques SNMP (CPU/RAM)
        \item Quarantaine automatique de containers suspects
        \item Rollback automatique en cas de détection d'anomalie
    \end{itemize}
    
    \item \textbf{Compliance as Code :}
    \begin{itemize}
        \item Tests de conformité PCI-DSS
        \item Tests de conformité GDPR
        \item Tests de conformité ISO 27001
        \item Génération automatique de rapports d'audit
    \end{itemize}
\end{itemize}

\subsection{Long Terme (6-12 mois)}

\begin{itemize}
    \item \textbf{Machine Learning pour Détection d'Anomalies :}
    \begin{itemize}
        \item Analyse de patterns de trafic réseau avec ML
        \item Prédiction de pannes basée sur l'historique
        \item Détection de comportements anormaux (APT - Advanced Persistent Threats)
        \item Modèles prédictifs pour l'optimisation des ressources
    \end{itemize}
    
    \item \textbf{Infrastructure as Code Security :}
    \begin{itemize}
        \item Scan des fichiers Terraform/CloudFormation
        \item Validation des configurations Kubernetes
        \item Policy as Code avec Open Policy Agent (OPA)
        \item GitOps security pipeline complet
    \end{itemize}
    
    \item \textbf{Threat Intelligence Integration :}
    \begin{itemize}
        \item Intégration avec des feeds de threat intelligence (MISP, AlienVault OTX)
        \item Blocage automatique d'IPs malveillantes
        \item Mise à jour automatique des règles de firewall
        \item Corrélation avec des IOC (Indicators of Compromise)
    \end{itemize}
\end{itemize}

% ============================================================
% CHAPITRE 10 : CONCLUSION
% ============================================================

\chapter{Conclusion}

\section{Synthèse des Réalisations}

L'intégration de ce système de sécurité et de monitoring réseau avancé transforme le projet de microservices e-commerce d'une simple démonstration technique en un système robuste, proche d'une architecture de production sécurisée.

\textbf{Apports principaux :}
\begin{itemize}
    \item \textbf{Visibilité complète} : Grâce aux outils nmap, SNMP, PowerShell, tcpdump, l'infrastructure est entièrement observable
    \item \textbf{Détection proactive} : Les vulnérabilités sont identifiées avant exploitation
    \item \textbf{Surveillance continue} : Monitoring 24/7 automatisé avec génération de rapports périodiques
    \item \textbf{Documentation automatisée} : Les rapports détaillés facilitent les audits de conformité
    \item \textbf{Réponse rapide aux incidents} : Les scripts permettent un diagnostic rapide et précis
\end{itemize}

\section{Positionnement DevSecOps}

Cette approche holistique de la sécurité et de l'observabilité s'inscrit parfaitement dans une démarche \textbf{DevSecOps moderne}, où :
\begin{itemize}
    \item La sécurité n'est plus une étape finale mais un \textbf{processus continu}
    \item Les développeurs, opérationnels et équipes de sécurité partagent la \textbf{responsabilité collective}
    \item L'automatisation maximale réduit les erreurs humaines et accélère les cycles
    \item La conformité est facilitée par la traçabilité et la documentation automatique
\end{itemize}

\section{Extensibilité et Réutilisabilité}

Les scripts développés présentent plusieurs avantages :
\begin{itemize}
    \item \textbf{Modulaires} : Chaque script peut être utilisé indépendamment
    \item \textbf{Extensibles} : Faciles à adapter pour d'autres infrastructures
    \item \textbf{Versionnés} : Hébergés dans Git, permettant un suivi des évolutions
    \item \textbf{Documentés} : Commentaires détaillés facilitant la maintenance
    \item \textbf{Portables} : Fonctionnent dans tout environnement Docker
\end{itemize}

Ils constituent une \textbf{base solide} pour construire un centre opérationnel de sécurité (SOC) automatisé à l'échelle de l'entreprise.

\section{Recommandation Finale}

Pour un déploiement en environnement de production réel, il est recommandé de :
\begin{enumerate}
    \item Implémenter les améliorations court terme (OWASP ZAP, Trivy, alerting externe)
    \item Planifier l'intégration d'un SIEM complet (ELK Stack ou Splunk)
    \item Établir des procédures de réponse aux incidents basées sur les alertes
    \item Former les équipes à l'utilisation des outils et à l'interprétation des rapports
    \item Mettre en place des revues de sécurité régulières (hebdomadaires/mensuelles)
    \item Documenter les procédures opérationnelles standard (SOP) pour chaque scénario
\end{enumerate}

\section{Mot de Fin}

La sécurité est un voyage continu, pas une destination. Les outils et processus déployés dans ce projet fournissent une fondation robuste, mais doivent être constamment évalués, améliorés et adaptés face à l'évolution constante des menaces cybernétiques.

\vspace{1cm}

\begin{center}
\textit{« La sécurité n'est pas un produit, mais un processus. »} \\
\textbf{-- Bruce Schneier, cryptographe et expert en sécurité}
\end{center}

% ============================================================
% ANNEXES
% ============================================================

\appendix

\chapter{Commandes de Référence Rapide}

\section{Commandes Docker}

\begin{lstlisting}[language=bash, caption=Commandes Docker Utiles]
# Démarrer tous les containers
docker-compose up -d

# Rebuild et redémarrer le container security-tools
docker-compose up -d --build security-tools

# Accéder au shell du container
docker exec -it security-tools bash

# Voir les logs en temps réel
docker logs -f security-tools

# Arrêter et supprimer tous les containers
docker-compose down

# Nettoyer les volumes
docker-compose down -v
\end{lstlisting}

\section{Commandes PowerShell}

\begin{lstlisting}[language=PowerShell, caption=Commandes PowerShell Utiles]
# Health check manuel
docker exec -it security-tools pwsh /security-tools/scripts/monitor-services.ps1

# Audit de sécurité
docker exec -it security-tools pwsh /security-tools/scripts/security-audit.ps1

# Monitoring continu (5 minutes d'intervalle)
docker exec -d security-tools pwsh /security-tools/scripts/automated-monitor.ps1

# Monitoring continu (30 secondes d'intervalle)
docker exec -d security-tools pwsh /security-tools/scripts/automated-monitor.ps1 `
    -IntervalSeconds 30
\end{lstlisting}

\section{Commandes nmap}

\begin{lstlisting}[language=bash, caption=Commandes nmap Courantes]
# Scan de base avec détection de version
docker exec -it security-tools nmap -sV -p 4000 order

# Scan de vulnérabilités
docker exec -it security-tools nmap --script vuln nginx -p 80,443

# Scan SSL complet
docker exec -it security-tools nmap --script ssl-cert,ssl-enum-ciphers nginx -p 443

# Scan de tous les services
docker exec -it security-tools bash /security-tools/scripts/network-scan.sh
\end{lstlisting}

\chapter{Glossaire}

\begin{description}
    \item[APT (Advanced Persistent Threat)] Menace persistante avancée : attaque ciblée et sophistiquée visant à infiltrer un réseau sur une longue période
    
    \item[CI/CD (Continuous Integration/Continuous Deployment)] Intégration et déploiement continus : pratiques DevOps d'automatisation des pipelines
    
    \item[CVE (Common Vulnerabilities and Exposures)] Base de données publique de vulnérabilités de sécurité connues
    
    \item[DevSecOps] Approche intégrant la sécurité dans les pratiques DevOps dès les phases de développement
    
    \item[IOC (Indicator of Compromise)] Indicateur de compromission : artefact observé sur un réseau ou système indiquant une intrusion
    
    \item[MIB (Management Information Base)] Base de données hiérarchique utilisée par SNMP pour organiser les informations gérées
    
    \item[NSE (Nmap Scripting Engine)] Moteur de scripts Lua intégré à nmap pour des scans avancés
    
    \item[OID (Object Identifier)] Identifiant unique dans la hiérarchie MIB SNMP
    
    \item[SIEM (Security Information and Event Management)] Système de gestion centralisée des événements et informations de sécurité
    
    \item[SOC (Security Operations Center)] Centre opérationnel de sécurité : équipe et outils dédiés à la surveillance de la sécurité
\end{description}

\chapter{Bibliographie et Ressources}

\begin{thebibliography}{99}

\bibitem{nmap_book}
Gordon Lyon (Fyodor),
\textit{Nmap Network Scanning: The Official Nmap Project Guide to Network Discovery and Security Scanning},
Insecure.Com LLC, 2009.

\bibitem{snmp_rfc}
IETF,
\textit{RFC 3411-3418: Simple Network Management Protocol (SNMP) Version 3},
Internet Engineering Task Force, 2002.

\bibitem{docker_security}
Adrian Mouat,
\textit{Docker Security: Using Containers Safely in Production},
O'Reilly Media, 2018.

\bibitem{devsecops}
Shannon Lietz et al.,
\textit{DevSecOps Manifesto},
\url{https://www.devsecops.org/}, 2020.

\bibitem{owasp_top10}
OWASP Foundation,
\textit{OWASP Top 10 - 2021: The Ten Most Critical Web Application Security Risks},
\url{https://owasp.org/www-project-top-ten/}, 2021.

\bibitem{powershell_docs}
Microsoft,
\textit{PowerShell Documentation},
\url{https://docs.microsoft.com/en-us/powershell/}, 2025.

\end{thebibliography}

\end{document}
